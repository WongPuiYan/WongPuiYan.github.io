[{"categories":["算法"],"content":"移除链表元素 ","date":"2023-07-01","objectID":"/203-remove-linked-list-elements/:0:0","tags":["链表"],"title":"移除链表元素","uri":"/203-remove-linked-list-elements/"},{"categories":["算法"],"content":"203. 移除链表元素 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def removeElements(self, head: ListNode, val: int) -\u003e ListNode: p_h = ListNode() p_h.next = head p = p_h while p: if p.next and p.next.val == val: p.next = p.next.next else: p = p.next return p_h.next ","date":"2023-07-01","objectID":"/203-remove-linked-list-elements/:1:0","tags":["链表"],"title":"移除链表元素","uri":"/203-remove-linked-list-elements/"},{"categories":["算法"],"content":"螺旋矩阵 II ","date":"2023-07-01","objectID":"/59-spiral-matrix-ii/:0:0","tags":["数组","双指针","滑动窗口"],"title":"螺旋矩阵 II","uri":"/59-spiral-matrix-ii/"},{"categories":["算法"],"content":"59. 螺旋矩阵 II 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 class Solution: def generateMatrix(self, n: int) -\u003e List[List[int]]: res = [[0] * n for _ in range(n)] x, y = 0, 0 loop = mid = n // 2 count = 1 for i in range(1, loop + 1): # 从左到右 for j in range(y, n - i): res[x][j] = count count += 1 # 从上到下 for j in range(x, n - i): res[j][n - i] = count count += 1 # 从右到左 for j in range(n - i, y, -1): res[n - i][j] = count count += 1 # 从下到上 for j in range(n - i, x, -1): res[j][y] = count count += 1 x += 1 y += 1 if n % 2 != 0: res[mid][mid] = count return res ","date":"2023-07-01","objectID":"/59-spiral-matrix-ii/:1:0","tags":["数组","双指针","滑动窗口"],"title":"螺旋矩阵 II","uri":"/59-spiral-matrix-ii/"},{"categories":["算法"],"content":"长度最小的子数组 ","date":"2023-07-01","objectID":"/209-minimum-size-subarray-sum/:0:0","tags":["数组","双指针","滑动窗口"],"title":"长度最小的子数组","uri":"/209-minimum-size-subarray-sum/"},{"categories":["算法"],"content":"209. 长度最小的子数组 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -\u003e int: res = len(nums) + 1 sum = l = 0 for r in range(res - 1): sum += nums[r] while sum \u003e= target: res = min(res, r - l + 1) sum -= nums[l] l += 1 return 0 if res == len(nums) + 1 else ress ","date":"2023-07-01","objectID":"/209-minimum-size-subarray-sum/:1:0","tags":["数组","双指针","滑动窗口"],"title":"长度最小的子数组","uri":"/209-minimum-size-subarray-sum/"},{"categories":["算法"],"content":"有序数组的平方 ","date":"2023-06-30","objectID":"/977-squares-of-a-sorted-array/:0:0","tags":["数组","双指针"],"title":"有序数组的平方","uri":"/977-squares-of-a-sorted-array/"},{"categories":["算法"],"content":"977. 有序数组的平方 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 class Solution: def sortedSquares(self, nums: List[int]) -\u003e List[int]: n = len(nums) res = [0] * n left, right, pos = 0, n - 1, n - 1 while left \u003c= right: if nums[left] ** 2 \u003c nums[right] ** 2: res[pos] = nums[right] ** 2 right -= 1 else: res[pos] = nums[left] ** 2 left += 1 pos -= 1 return res ","date":"2023-06-30","objectID":"/977-squares-of-a-sorted-array/:1:0","tags":["数组","双指针"],"title":"有序数组的平方","uri":"/977-squares-of-a-sorted-array/"},{"categories":["算法"],"content":"移除元素 ","date":"2023-06-29","objectID":"/27-remove-element/:0:0","tags":["数组","双指针"],"title":"移除元素","uri":"/27-remove-element/"},{"categories":["算法"],"content":"27. 移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 # 双指针 class Solution: def removeElement(self, nums: List[int], val: int) -\u003e int: slow = 0 for fast in nums: if fast != val: nums[slow] = fast slow += 1 return slow # 双指针优化 class Solution: def removeElement(self, nums: List[int], val: int) -\u003e int: left, right = 0, len(nums) while left \u003c right: if nums[left] == val: nums[left] = nums[right - 1] right -= 1 else: left += 1 return left // 双指针 func removeElement(nums []int, val int) int { var( slow int = 0 ) for _, fast := range nums{ if (fast != val) { nums[slow] = fast slow++ } } return slow } // 双指针优化 func removeElement(nums []int, val int) int { var( left int = 0 right int = len(nums) ) for(left \u003c right) { if nums[left] == val { nums[left] = nums[right - 1] right-- }else{ left++ } } return left } ","date":"2023-06-29","objectID":"/27-remove-element/:1:0","tags":["数组","双指针"],"title":"移除元素","uri":"/27-remove-element/"},{"categories":["算法"],"content":"二分查找 ","date":"2023-06-28","objectID":"/704-binary-search/:0:0","tags":["数组","双指针","二分查找"],"title":"二分查找","uri":"/704-binary-search/"},{"categories":["算法"],"content":"704. 二分查找 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 Class Solution: def search(sefl, nums: List[int], target: int) -\u003e int: left, right = 0, len(nums) - 1 while left \u003c= right: mid = left + (right - left) // 2 if target \u003e nums[mid]: left = mid + 1 elif target \u003c nums[mid]: right = mid - 1 else: return mid return -1 func search(nums []int, target int) int { var( left int = 0 right int = len(nums) - 1 mid int ) for left \u003c= right { mid = left + (right - left) // 2 if (num[mid] \u003c target){ left = mid + 1 }else if (num[mid] \u003e target){ right = mid - 1 }else{ return mid } } return -1 } ","date":"2023-06-28","objectID":"/704-binary-search/:1:0","tags":["数组","双指针","二分查找"],"title":"二分查找","uri":"/704-binary-search/"},{"categories":null,"content":"POSTs first print(\"Hello World\") ","date":"2023-06-27","objectID":"/base/:0:0","tags":null,"title":"Base","uri":"/base/"}]